# webpack构建优化讲解

## 什么问题

一些老的项目还在使用vue-cli脚手架，然后启动是非常的慢
原因：基于webpack的项目，即便是开发环境下，也是要先打包才能在浏览器看到效果

## 解决思路

speed-meausre-webpack-plugin：该插件主要用于分析打包的时候各个地方的耗时情况。
分析过后，往往存在这么几个方面比较耗时：

1.js编译：Babel编译js的代码花费了大量时间。
2.打包时间：Webpack的模块打包花费了很长时间，特别是在处理大型依赖和复杂的项目结构时。
3.插件耗时：一些插件，如TerserWebpackPlugin(用于代码压缩)，在处理大量代码时会变得非常慢。
4.文件读取与写入：文件系统操作，特别是读取和写入缓存，耗时较长。
5.热更新（HMR)：在开发环境中，热更新的处理时间也较长，特别是在修改较多文件时。

确定了问题之后，就可以逐个优化：

1.用swc替换babel

2.使用thread-loader

3.利用webpack5的持久化缓存技术

4.开发环境去掉hash，生产环境要保留

5.升级老旧的plugin

## 解决细讲

### 1.使用speed-meausre-webpack-plugin进行耗时分析

回头会生成一份报告：
1.总体构建时间：Webpack 完整构建的总时间。
2.各个阶段的耗时：例如，解析依赖、构建模块、优化和输出资源等阶段的时间。
3.插件耗时：每个插件在构建过程中所花费的时间。
4.loader 耗时：每个loader 处理文件时所花费的时间。

还有一个常用插件：

- Webpack Bundle Analyzer: 主要是分析打包后资源文件的大小，会生成一个交互式的可视化图表。
- Speed Measure Webpack Plugin: 主要分析Webpack构建过程中的时间消耗。

### 2.用swc 替换 babel

全称是Speedy Web Compiler, 它是一个使用	Rust编写的编译器。

swc 特点：

​	1.高性能

​	2.兼容性

​	3.生态系统

使用sec替换babel之后，能够获取到性能上面的收益：

​	1.编译速度

​	2.多线程处理

​	3.内存管理

### 3.使用thread-loader

thread-loader是一个 Webpack的loader，可以将某些耗时的操作（如文件编译和转换）放在子线程中执行，从而减少主线程的负载，提高构建性能。

thread-loader主要提供的也就是多线程并行处理的优势：

- 单线程瓶颈：默认情况下，Webpack在主线程中逐个处理文件。对于大型项目或复杂的转换操作，这种单线程模式可能会导致严重的性能瓶颈。
- 并行加速：thread-loader通过创建多个子线程，并行处理文件，从而减少主线程的负载，加速整个编译过程。

4.利用webpack5的持久化缓存技术

持久化缓存技术是webpack5引入的新技术，可以对构建内容进行缓存：

memony：缓存在内存中，适用于开发环境

filesystem：以文件的形式缓存在磁盘上，适用于是生产环境

一般缓存的内容：

1.模块缓存

2.解析缓存

3.插件缓存

5.开发环境去掉hash

 在 webpack 配置中，hash 的目的是为了生成唯一的文件名：bundle.(hash).js
不同环境下对hash的需求是不一样的：

- 开发环境：频繁进行代码修改和构建，**不需要长时间缓存**，生成hash会增加不必要的构建时间。
- 生产环境：希望生成hash，以便**利用浏览器缓存机制**，提高加载速度。

因此在webpack配置文件 里面，就可以动态的配置是否要生成hash：

## 难点描述

模拟问题：我看到你写了一个项目亮点，是优化webpack构建时间，这边关于webpack的打包流程，你有了解过么？|


1.初始化：webpack通过配置文件和Shell参数，初始化参数，确定入口文件、输出路径、加载器、插件等信息。接下来读取
配置文件，并合并默认配置、CL参数等，生成最终的配置对象。
2.编译：从入口文件开始，递归解析模块依赖，找到所有需要打包的模块。之后使用loader对每个模块进行转换，转换成浏览
器能够识别的JS代码。
3.构建模块依赖图：webpack会为每个模块创建一个模块对象，并根据模块的依赖关系，生成一个模块依赖图（Dependency
Graph)。
4.生成代码块（chunk）：根据入口和依赖图，将所有模块分组，生成一个个包含多个模块的代码块（chunk），这些chunk会
根据配置生成不同的输出文件。
5，输出：将生成的代码块输出到指定的文件夹，并根据配置生成对应的静态资源文件。
6.插件处理：在整个构建过程中，webpack会在特定的生命周期钩子上执行插件，插件可以对打包的各个阶段进行干预和处
理。
正是因为了解webpack整体的打包流程，所以我发现了很多可以优化的地方，然后进一步着力于构建的优化，大幅度缩减了构建
所花费的时间。

模拟问题：我看到你写的构建时间从8min缩减至10s内，那么你能具体说一下你是如何做的么？还有你这里所写的所缩减的时间，是具
体测量了的么？通过什么方式去测量的？
问题分析
1.简单介绍一下做这个事情的背景
2.通过什么工具去量化时间
3.你思考的方案以及最终落地的方案
4.落地方案的一个整体效果

我先说一下当时为什么需要做这个事儿吧。我们项目一开始就是基于webpack搭建的，随着后面项目越来越大，模块越来越多，
构建的时间也越来越夸张。最开始还能够忍受，早上到公司先把项目跑起来，等它构建，然后开始小组会议，小组会议结束后回去差
不多项目也跑起来了。但是后面随着模块越来越多，会都开完了回去项目都还在构建，于是我们小组讨论，这个问题必须得解决了，
因为整个团队里面，就我对工程化有一些研究，所以指派我来完成这项任务。（简单阐述做这个事情的背景）
我当时首先想到了Vite，因为Vite可以直接跳过打包的步骤，但是因为我们这个项目基于webpack，体量很大，里面用到了很多
webpack生态的插件和loader，冒然迁移到Vite可能会带来一些未知的风险，例如在Vite生态中找不到对标的插件，那么我们
就需要在Vite中通过自定义插件来实现那个插件的功能，这个工作量是不可预估的。（强调你是如何思考的）
所以，既然无法切换构建工具，那意味着无法跳过打包这个过程，因此我需要知道是哪些地方消耗了那么多时间。在webpack中
有一个插件speed-measure-webpack-plugin，我就是通过这个插件去查看的构建时间，它会出一份报告，包含总体构建时间、
各阶段的耗时、插件耗时、loader耗时，这样我就能非常清楚究竟是哪些地方耗时。
通过插件的分析结果来看，我发现Babel在编译JS时特别耗时，还有就是一些loader，比如处理CSs的css-loader，在解析和处
理过程中也挺耗时的。因此我考虑的主要优化方案有：
1.用swc替换babel进行编译工作
2.thread-loader解决loader解析耗时问题
另外还配合了一些额外的优化手段。最终落地的方案效果非常好，再次用speed-measure-webpack-plugin插件进行构建时间分
析，基本上构建时间在10多秒左右。

### 																	技术叙述点

1.SWC 

模拟问题：你说你用到了swc，那么就先讲一讲这个吧，什么是swc，它的优势有什么？你为什么用它来替换babel？
问题分析
享了
1.简单介绍什么是swc
2.结合你的项目说一下优化前后的区别
3.放下一个钩子
参考答案
swc是一个用rust写的 JS/TS编译器，因为基于rust，所以编译速度非常快，而且swc能够兼容大多数babel插件和配置，因此迁
移起来没有太高的成本。
做开始做优化之前，我们项目的构建时间差不多要花费8~10分钟左右，替换为swc编译后，构建时间减少到了约3分钟左右。
“所以整个优化方案中swc是最重要，占大头的。而loader解析耗时的问题，我是通过thread-loader来解决的，thread-
loader不知道面试老师您之前了解过么？”*

2.thread-loader

模拟问题：你这边说一下呢？它是如何解决loader解析耗时问题的？
教
问题分析
1.介绍一下thread-loader
2.结合你的项目，用了后的效果
3.抛出下一个钩子
参考答案
thread-oader可以通过多线程并行处理loader操作，这样就减少了主线程的负载。
当我们用了thread-loader以后，处理图片、CSS相关loader的耗时问题也就解决了，构建时间进一步缩减到了2分钟。
所以swc和thread-loader是整个优化方案中最核心的手段，“剩下一些其他的优化手段，倒不是说没用，但主要是起到一个锦上
添花的作用，一步一步将2分钟的构建时间继续优化到10s以内。就看老师您这边需要我介绍额外的那些优化手段不？