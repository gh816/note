# **大文件上传**

前端实现：首先

1.首先我们得获取到上传文件的大小，设置单个文件切片的大小。

2.用FileReader()方法来读取文件内容，通过fileReader.readAsArrayBuffer()异步读取文件内容，等读取完触发onload事件。

3.在onload回调中使用SparkMD5.ArrayBuffer来计算哈希值。

4.通过文件切割的片段来循环在循环过程中创建一个对象来存储文件的子集chunk这个是用到Blob的slice方法来截取文件一部分数据。还存储一个带hash的文件名。

5.创建一个formData对象来存储发给后端的字段包括文件的hash值文件吗chunk对象

后端实现：后端使用koa2来实现的，首先获取获取到前端传过来的chunk对象，和上过来的文件对象，然后获取hash，索引，总块数，文件名。然后创建一个临时存放文件的目录，将上传的文件片段移动到临时目录，获取临时目录的文件数量，判断是否所有文件片段都上传完了。所有文件上传完毕之后，就把临时文件合并成一个完成的文件。

优化：

设置一个最大的请求数，当正在上传的请求数量小于最大并发数时，添加新的上传请求，当大于最大并发数，Promise.race()来判断一个最早完成的请求，然后哪这个请求移除掉再添加新的请求。

断点续传实现：

1.在上传过程中，记录已成功上传的文件块索引，以便后续断点续传时跳过这些文件块，

2. 在上传向服务端发送请求，查询当前文件已上传的文件块列表

处理上传异常

在上传过程中记录上传失败的文件块信息，在上传完成后，检查失败的文件块列表，进行重试
